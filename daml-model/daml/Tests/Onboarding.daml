--
-- Copyright (c) 2022, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module Tests.Onboarding where

import Daml.Script
import Model.BankBIC
import Model.Balance
import DA.Set qualified as Set
import DA.Foldable (forA_)
import DA.Optional (whenSome)
import DA.Functor (void)

type EntityNameBicParticipantName = (Text, Text, Text)
type EntityToBicMapping = [EntityNameBicParticipantName]
type Parties = [Party]

data Entity = Entity
  with
    id : Int
    name : Text
    participant : ParticipantName
    iban : Optional Text
    bic : Optional Text
    baseUrl : Text
    clientAccounts : [ClientAccount]
    children : [Entity]

data ClientAccount = ClientAccount
  with
    name : Text
    iban : Text
    shouldAllocateParty : Bool
    participant : ParticipantName

data Output = Output
  with
    id : Int
    baseUrl : Text
    damlPartyId : Text
    name : Text
  deriving (Show)

onboarding : Entity -> Script [Output]
onboarding entity = do
  scheduler <- allocatePartyOn "Scheduler" (ParticipantName "schedulerParticipant")
  assembler <- allocatePartyOn "Assembler" (ParticipantName "assemblerParticipant")
  (_, output) <- setupAccount entity [] scheduler assembler
  pure output

setupAccount : Entity -> [Party] -> Party -> Party -> Script (Party, [Output])
setupAccount entity parties scheduler assembler = do
  party <- allocatePartyOn entity.name entity.participant
  whenSome entity.bic \bic ->
    void $ party `submit` createCmd
      BankBIC
        with
          bic
          banks = Set.singleton party
          schedulers = Set.singleton scheduler
          assemblers = Set.singleton assembler
  forA_ entity.clientAccounts \account -> createAccount party account
  outputs <- concat <$> mapA (\child -> setupAccount' party child parties scheduler assembler) entity.children
  pure (party, 
        Output with
            id = entity.id
            baseUrl = entity.baseUrl
            damlPartyId = partyToText party
            name = entity.name
        :: outputs
        )
  where createAccount provider account = do 
          ownerParty <- if account.shouldAllocateParty
            then Some <$> allocatePartyOn account.name account.participant
            else pure None
          provider `submit` createCmd
            Balance
              with
                iban = account.iban
                provider = provider
                owner = BalanceOwner with name = account.name, party = ownerParty
                currency = "USD"
                amount = 0.0
        setupAccount' provider child parties scheduler assembler = do
          (childParty, parties') <- setupAccount child parties scheduler assembler
          whenSome child.iban $ \iban ->
            void $ provider `submit` createCmd
              Balance
                with
                  iban
                  provider = provider
                  owner = BalanceOwner with name = child.name, party = Some childParty
                  currency = "USD"
                  amount = 0.0
          return parties'

onboardingTest : Script ()
onboardingTest = do
  let entity = Entity
        with
          id = 1
          name = "FED1"
          participant = ParticipantName "Somewhere"
          iban = None
          bic = None
          baseUrl = ""
          clientAccounts = []
          children = [
            Entity with
              id = 2
              name = "Cello Bank"
              participant = ParticipantName "Who Knows Where"
              iban = Some "US87CITI83042524873201"
              bic = Some "CITIUS33"
              baseUrl = ""
              clientAccounts = []
              children = []
            ]

  outputs <- onboarding entity

  debug outputs
  pure ()

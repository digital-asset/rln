--
-- Copyright (c) 2022, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# LANGUAGE AllowAmbiguousTypes #-}

module Trigger.AutoApprove where

import DA.Action (void, when)
import DA.Foldable (mapA_, forA_)
import DA.List (head)
import DA.Optional (fromSome, optionalToList)
import Daml.Trigger
import Model.Blacklist
import Model.Balance
import Model.LoanConfig
import Workflow.TransferProposal
import Workflow.Data
import DA.Map qualified as Map

autoApproveTrigger : Trigger ()
autoApproveTrigger = Trigger
  { initialize = pure ()
  , updateState = \_ -> pure ()
  , rule = autoApprove
  , registeredTemplates = RegisteredTemplates [
      registeredTemplate @AutoApproveTransferProposalMarker,
      registeredTemplate @TransferProposal,
      registeredTemplate @Blacklist,
      registeredTemplate @Balance,
      registeredTemplate @LoanConfig
    ]
  , heartbeat = None
  }

autoApprove : Party -> TriggerA () ()
autoApprove sender = do
  blackLists <- query @Blacklist

  when (1 /= length blackLists) $ error "There should be only one Blacklist"
  let (_, blacklist) = head blackLists

  transferProposals <- query @TransferProposal
  autoApproveMarkersWithCids <- query @AutoApproveTransferProposalMarker
  let markers = Map.fromList $ (\(_, marker) -> (marker.address, marker)) <$> autoApproveMarkersWithCids

  forA_ transferProposals \(cid, transferProposal) ->
    case (findProposalMarker transferProposal markers, transferProposal.step.sender, transferProposal.step.receiver) of
      (None, _, _) ->
        pure ()
      (Some _, None, None) -> -- impossible
        pure ()
      (Some marker, Some sender, Some receiver) -> do
        handleProposalForSender transferProposal sender blacklist cid
        handleProposalForReceiver transferProposal cid
      (Some marker, Some sender, None) ->
        handleProposalForSender transferProposal sender blacklist cid
      (Some marker, None, Some receiver) ->
        handleProposalForReceiver transferProposal cid

-- Helper functions
lockBalanceCommand: TransferProposal -> ContractId Balance -> Command
lockBalanceCommand transferProposal@TransferProposal{step = SettlementStep{..}} balanceCid =
  let lockBalance = Lock with amountToLock = delivery.amount;
                                identifier = toIdentifier transferProposal in
  exerciseCmd balanceCid lockBalance

getBalanceOwnerFromKey: BalanceKey -> TriggerA () BalanceOwner
getBalanceOwnerFromKey balanceKey = do
  queryContractKey @Balance balanceKey >>= \case
    Some (_, Balance{..}) -> pure $ owner
    None -> error $ "No Balance found for balanceKey: " <> (show balanceKey)

createIncomingBalance: TransferProposal -> TriggerA () Command
createIncomingBalance transferProposal@TransferProposal{owner; step = SettlementStep{..}} = do
  let iban = fromSome receiver
      provider = owner
      currency = delivery.label
      amount = delivery.amount
  balanceOwner <- getBalanceOwnerFromKey (BalanceKey with provider; iban)
  pure $ createCmd IncomingBalance with
    balance = Balance with owner = balanceOwner, ..
    identifier = toIdentifier transferProposal

rejectProposal: Text -> ContractId TransferProposal -> TriggerA () ()
rejectProposal reason proposalCid =
  let rejection = RejectProposal with reason = Some reason in
  void $ emitCommands [exerciseCmd proposalCid rejection] [toAnyContractId proposalCid]

approveProposal: Text -> ContractId TransferProposal -> Optional (ContractId Balance) -> Command -> TriggerA () ()
approveProposal reason proposalCid balanceCidOpt balanceCmd =
  let approval = ApproveProposal with
                      reason = Some reason;
                       settleOnLedger = True
      pendingCids = map toAnyContractId (optionalToList balanceCidOpt) <> [toAnyContractId proposalCid] in
  void $ emitCommands [exerciseCmd proposalCid approval, balanceCmd] pendingCids

involveBlackListParty : TransferProposal -> Blacklist -> Bool
involveBlackListParty TransferProposal{step, approvers} Blacklist{banks, accounts} =
  let receiverIsBlackListed = case step.receiver of
                                Some receiverIban -> receiverIban `elem` accounts
                                None -> False in
  let senderIsBlackListed = case step.sender of
                                  Some senderIban -> senderIban `elem` accounts
                                  None -> False in
  let bankOnSettlementChainBlackListed = any (`elem` banks) approvers in
  receiverIsBlackListed || senderIsBlackListed || bankOnSettlementChainBlackListed

findProposalMarker : TransferProposal -> Map.Map Text AutoApproveTransferProposalMarker -> Optional AutoApproveTransferProposalMarker
findProposalMarker transferProposal@TransferProposal{ step = SettlementStep{ sender, receiver } } markers =
  case (sender, receiver) of
    (None, None) -> None
    (Some iban, None) -> do
      marker <- Map.lookup iban markers
      if matchesMarker transferProposal.step.delivery.amount marker then Some marker else None
    (None, Some iban) -> do
      marker <- Map.lookup iban markers
      if matchesMarker transferProposal.step.delivery.amount marker then Some marker else None
    (Some senderIban, Some receiverIban) -> do
      marker1 <- Map.lookup senderIban markers
      marker2 <- Map.lookup receiverIban markers
      pure $ getStrictMarker marker1 marker2

findBalance : TransferProposal -> Text -> TriggerA () (Optional (ContractId Balance, Balance))
findBalance transferProposal@TransferProposal{owner; step} iban = do
  let
    Instrument{amount, label} = step.delivery
    amountRequired = amount
    currencyRequired = label
    identifier = toIdentifier transferProposal
    provider = owner
  queryContractKey (BalanceKey with ..) >>= \case
    Some balance@(_, Balance{amount;currency}) ->
      if currency /= currencyRequired then
        pure $ trace ("Account " <> iban <> "does not hold required currency " <> currencyRequired) None
      else pure $ Some balance
    None -> pure $ trace ("No Balance exist for account" <> iban) None

createLoanForSender : TransferProposal -> Decimal -> Text -> ContractId TransferProposal -> TriggerA () ()
createLoanForSender transferProposal loanAmount sender cid = do
  case transferProposal.step.sender of
    Some sender -> do
      let balanceKey = BalanceKey with iban = sender, provider = transferProposal.owner
      loanConfig <- queryContractKey @LoanConfig balanceKey
      case loanConfig of
        Some (loanConfigCid, lc) -> do
          let cmd = exerciseCmd loanConfigCid (CreateLoan with loanAmount = loanAmount)
          void $ emitCommands [cmd] [toAnyContractId cid] 
        None -> pure $ trace ("No LoanConfig found for BalanceKey" <> show balanceKey) ()
    None -> pure $ trace "Unable request loan for empty sender"  ()


handleProposalForSender : TransferProposal -> Text -> Blacklist -> ContractId TransferProposal -> TriggerA () ()
handleProposalForSender transferProposal sender blacklist cid = do
  if involveBlackListParty transferProposal blacklist then
      rejectProposal "Rejected due to blacklist" cid
  else do
    maybeBalance <- findBalance transferProposal sender
    mapA_ (\(balanceCid, balance) -> do
          if transferProposal.step.delivery.amount <= balance.amount then do
            let loanAmount = transferProposal.step.delivery.amount - balance.amount
            createLoanForSender transferProposal loanAmount sender cid
            maybeBalance <- findBalance transferProposal sender
            pure ()
          else
            pure ()
      ) maybeBalance
    
    case maybeBalance of
      Some (balanceCid, balance) | transferProposal.step.delivery.amount <= balance.amount ->
        approveProposal
          "Approved Proposal as sender has enough balance and no banks/accounts are blacklisted"
          cid
          (Some balanceCid)
          (lockBalanceCommand transferProposal balanceCid)
      _ ->
        rejectProposal "Rejected due to not enough balance"  cid

handleProposalForReceiver : TransferProposal -> ContractId TransferProposal -> TriggerA () ()
handleProposalForReceiver transferProposal cid = do
  createIncomingBalanceCmd <- createIncomingBalance transferProposal
  approveProposal "Approved Proposal for receiver" cid None createIncomingBalanceCmd

matchesMarker : Decimal -> AutoApproveTransferProposalMarker -> Bool
matchesMarker _ AutoApproveTransferProposalMarker { autoApproveType = FullAuto } = True
matchesMarker amount AutoApproveTransferProposalMarker { autoApproveType = LimitedMaxAmount maxAmount } = amount <= maxAmount

getStrictMarker : AutoApproveTransferProposalMarker -> AutoApproveTransferProposalMarker -> AutoApproveTransferProposalMarker
getStrictMarker m1@AutoApproveTransferProposalMarker { autoApproveType = LimitedMaxAmount maxAmount1 }
                m2@AutoApproveTransferProposalMarker { autoApproveType = LimitedMaxAmount maxAmount2 } = if maxAmount1 < maxAmount2 then m1 else m2
getStrictMarker m@AutoApproveTransferProposalMarker { autoApproveType = LimitedMaxAmount maxAmount } _ = m
getStrictMarker _ m@AutoApproveTransferProposalMarker { autoApproveType = LimitedMaxAmount maxAmount } = m
getStrictMarker m _                                                                                    = m

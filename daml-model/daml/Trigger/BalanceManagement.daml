--
-- Copyright (c) 2022, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module Trigger.BalanceManagement where

import DA.Foldable
import DA.Optional (fromSome, whenSome)
import Daml.Trigger
import Model.Balance
import Workflow.Data
import Workflow.TransferProposal
import Workflow.TransactionManifest
import Workflow.Instruction

balanceManagementTrigger : Trigger UnProcessedSettlements
balanceManagementTrigger = Trigger
  { initialize = pure []
  , updateState = addToUnProcessedTransactions
  , rule = updateBalance
  , registeredTemplates = RegisteredTemplates [
      registeredTemplate @SettlementFinalized,
      registeredTemplate @SettlementRejected,
      registeredTemplate @Instruction
    ]
  , heartbeat = None
  }

type GroupId = Text
data Settlement = Settlement with
    groupId : GroupId
    status  : SettlementStatus
data SettlementStatus =
    Finalized (ContractId SettlementFinalized)
  | Rejected (ContractId SettlementRejected)
type UnProcessedSettlements = [Settlement]

addToUnProcessedTransactions : Message -> TriggerUpdateA UnProcessedSettlements ()
addToUnProcessedTransactions (MTransaction Transaction{events}) =
    forA_ events markedAsProcessed
  where
    markedAsProcessed (CreatedEvent created) = do
      whenSome (fromCreated @SettlementFinalized created) $
        \(_, evidence, SettlementFinalized{groupId}) ->
          modify (Settlement groupId (Finalized evidence) ::)
      whenSome (fromCreated @SettlementRejected created) $
        \(_, evidence, SettlementRejected{groupId}) ->
          modify (Settlement groupId (Rejected evidence) ::)
    markedAsProcessed _else =
        pure ()
addToUnProcessedTransactions _any = pure ()

updateBalance: Party -> TriggerA UnProcessedSettlements ()
updateBalance provider = do
    unprocessedTransactions <- get
    forA_ unprocessedTransactions settleInstructionsForTransaction
    put []
  where
    getAllInstructionCidsForGroupId: GroupId -> TriggerA UnProcessedSettlements [ContractId Instruction]
    getAllInstructionCidsForGroupId targetGroupId =
      map fst <$> queryFilter @Instruction ((==targetGroupId) . (.groupId))
    settleInstructionsForTransaction: Settlement -> TriggerA UnProcessedSettlements ()
    settleInstructionsForTransaction transaction = do
      instructions <- getAllInstructionCidsForGroupId $ transaction.groupId
      let exerciseCall = case transaction.status of
            Finalized evidence -> (`dedupExercise` Settle with evidence)
            Rejected evidence -> (`dedupExercise` Cancel with evidence)
      forA_ instructions exerciseCall

lockBalanceCommand: TransferProposal -> ContractId Balance -> Command
lockBalanceCommand transferProposal@TransferProposal{step = SettlementStep{..}} balanceCid =
  let lockBalance = Lock with amountToLock = delivery.amount;
                                identifier = toIdentifier transferProposal in
  exerciseCmd balanceCid lockBalance

createIncomingBalance: TransferProposal -> TriggerA () Command
createIncomingBalance transferProposal@TransferProposal{owner; step = SettlementStep{..}} = do
  let iban = fromSome receiver
      provider = owner
      currency = delivery.label
      amount = delivery.amount
  balanceOwner <- getBalanceOwnerFromKey (BalanceKey with provider; iban)
  pure $ createCmd IncomingBalance with
    balance = Balance with owner = balanceOwner, ..
    identifier = toIdentifier transferProposal

getBalanceOwnerFromKey: BalanceKey -> TriggerA () BalanceOwner
getBalanceOwnerFromKey balanceKey = do
  queryContractKey @Balance balanceKey >>= \case
    Some (_, Balance{..}) -> pure $ owner
    None -> error $ "No Balance found for balanceKey: " <> (show balanceKey)
